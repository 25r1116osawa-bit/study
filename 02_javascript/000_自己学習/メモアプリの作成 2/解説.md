[ click ]
   ↓
 actions（何が起きたか）
   ↓
 dispatch
   ↓
 reducer（どう state が変わるか）
   ↓
 state 更新
   ↓
 render（見た目）


 ① なぜ actions は「処理」しない？
昔のあなたのコード
complete(index) {
  const todo = state.incomplete.splice(index, 1)[0];
  state.complete.push(todo);
  render();
}
何が起きたか
どう変えるか
いつ描画するか
👉 全部ごちゃ混ぜ


今回の actions
complete: (index) => ({ type: "complete", index })
これは
「◯番目のTodoを完了にした」
という 事実のメモ。
📌 ポイント
actions は 命令じゃない
イベントログ
② reducer は「stateの法律」
const reducer = (state, action) => {
  switch (action.type) {
    case "complete": {
      const todo = state.incomplete[action.index];
      return {
        incomplete: state.incomplete.filter((_, i) => i !== action.index),
        complete: [...state.complete, todo],
      };
    }
  }
};
ここでやってること
state を 直接触らない
「前の state → 新しい state」を返すだけ
📌 例えると
「法律（reducer）に従って、次の世界線を作る」
③ なぜ push / splice を殺すのか
NG
state.incomplete.push(todo);
同じ箱をいじる
変更前と変更後が区別できない
OK
[...state.incomplete, todo]
新しい箱を作る
React / Vue が変化を検知できる
📌 未来の自分を助けるため
④ dispatch は「唯一の入口」
dispatch(actions.complete(index));
なぜ直接 reducer 呼ばない？
ログ取れる
永続化できる
非同期足せる
👉 関所
⑤ render が楽になる理由
render は
state → DOM
だけ。
if 地獄にならない
バグが UI に漏れない
ここ超大事（安心ポイント）
❌ 毎回これで書け
⭕ こういう設計を「知ってる」状態になれ
あなたのレベルだと：
小規模 → 今までの書き方でOK
状態が増えた瞬間 → reducer 思考が刺さる
最短で慣れる練習（おすすめ）
ステップ1
state = reducer(state, action);
この1行を見て「世界が更新される」と思えるようになる
ステップ2
actions.add を1個増やす
ステップ3
「これは reducer 行きだな…」と感じられるようになる
最後に本音
あなたは
「書けない」んじゃなくて「設計を初めて触ってる」だけ。
ここを超えると：
React が急に分かる
他人のコードが読める
「なぜこう書くの？」が見える
ここは一緒に踏破しよう 💪
次は reducer を1ケースずつ図解する？